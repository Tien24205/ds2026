\documentclass[a4paper,12pt]{article}

% ============================
% Packages
% ============================
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{caption}

% ============================
% Title
% ============================
\title{Practical Work 2: MPI File Transfer}
\author{USTH -- Distributed Systems \\ Đỗ Minh Tiến -- 23BI14421}
\date{\today}

% ============================
% Code formatting
% ============================
\lstset{
    basicstyle=\ttfamily\small,
    frame=single,
    breaklines=true,
    columns=fullflexible,
    backgroundcolor=\color{gray!5}
}

% ============================
% Document
% ============================
\begin{document}
\maketitle

\section{Introduction}

In Practical Work 1, we implemented a basic TCP file-transfer service using sockets.  
In this Practical Work (Practical Work 2), we upgrade the system to use MPI (Message Passing Interface) instead of TCP.

MPI is a standardized communication library widely used in distributed and parallel computing.  
The goal of this practical work is to replace TCP send/receive operations with MPI message exchanges while keeping the same file-transfer logic: the client requests a filename, and the server returns the file size and file contents.

\section{Choice of MPI Implementation}

We chose \textbf{MPICH} for this practical work due to several advantages:

\begin{itemize}
    \item Lightweight, easy to install, and available on USTH lab machines.
    \item Fully supports the MPI-3 standard.
    \item Widely used for educational and research purposes.
    \item Provides simple tools: \texttt{mpicc}, \texttt{mpirun}, \texttt{mpiexec}.
\end{itemize}

\section{MPI Communication Design}

MPI assigns each running process a numeric ID called a \textbf{rank}.  
For this assignment, we use two processes:

\begin{itemize}
    \item \textbf{Rank 0: Client} — sends the filename and receives the file.
    \item \textbf{Rank 1: Server} — reads the file and sends it in chunks.
\end{itemize}

We define three message tags to separate communication phases:

\begin{itemize}
    \item \textbf{TAG\_FILENAME} — the client sends the filename.
    \item \textbf{TAG\_FILESIZE} — the server sends the file size.
    \item \textbf{TAG\_DATA} — the server sends binary file chunks.
\end{itemize}

\subsection*{Design Overview}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.92\textwidth]{mpi_design.png}
    \caption{MPI File Transfer Communication Flow}
\end{figure}

\section{System Organization}

The file-transfer workflow is as follows:

\begin{enumerate}
    \item The client (Rank 0) sends a filename.
    \item The server (Rank 1) checks whether the file exists.
    \item If the file does not exist, the server sends \texttt{-1}.
    \item If the file exists, the server sends the file size in bytes.
    \item The server sends the file in chunks of 4096 bytes.
    \item The client writes received chunks to a local output file.
\end{enumerate}

\subsection*{System Architecture}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.92\textwidth]{mpi_architecture.png}
    \caption{Overall MPI File Transfer Architecture}
\end{figure}

\section{Implementation}

Below is the core Python implementation using \texttt{mpi4py}.  
It demonstrates the required functionality with clear separation of client and server roles.

\subsection*{MPI Implementation Code}

\begin{lstlisting}[language=Python]
from mpi4py import MPI
import os

CHUNK = 4096
TAG_FILENAME = 0
TAG_FILESIZE = 1
TAG_DATA = 2

comm = MPI.COMM_WORLD
rank = comm.Get_rank()

# ===========================
# Rank 1 = Server
# ===========================
if rank == 1:
    print("[Server] Waiting for filename...")

    # Receive filename from client
    filename = comm.recv(source=0, tag=TAG_FILENAME)
    print(f"[Server] Client requested: {filename}")

    # File existence check
    if not os.path.exists(filename):
        print("[Server] File not found.")
        comm.send(-1, dest=0, tag=TAG_FILESIZE)

    else:
        size = os.path.getsize(filename)
        comm.send(size, dest=0, tag=TAG_FILESIZE)
        print(f"[Server] Sending {size} bytes...")

        with open(filename, "rb") as f:
            while True:
                data = f.read(CHUNK)
                if not data:
                    break
                comm.send(data, dest=0, tag=TAG_DATA)

        print("[Server] Transfer complete.")


# ===========================
# Rank 0 = Client
# ===========================
elif rank == 0:

    filename = input("Enter filename to download: ").strip()
    print(f"[Client] Requesting: {filename}")

    comm.send(filename, dest=1, tag=TAG_FILENAME)

    # Receive file size
    file_size = comm.recv(source=1, tag=TAG_FILESIZE)

    if file_size < 0:
        print("[Client] Server reports: File not found.")
    else:
        print(f"[Client] File size: {file_size}")

        output = "received_" + filename
        received = 0

        print("[Client] Receiving file...")

        with open(output, "wb") as f:
            while received < file_size:
                chunk = comm.recv(source=1, tag=TAG_DATA)
                f.write(chunk)
                received += len(chunk)

        print(f"[Client] File received successfully: {output}")
\end{lstlisting}

\section{Who Did What}

\begin{itemize}
    \item \textbf{Rank 0 (Client)}: Sends the requested filename, receives the file size, reads incoming data chunks, reconstructs the file, and handles all error cases.
    \item \textbf{Rank 1 (Server)}: Receives the filename, validates file existence, sends the size or an error signal, and transmits the file in chunks.
\end{itemize}

\section{Conclusion}

This practical work successfully demonstrates how a conventional TCP-based file-transfer service can be migrated to the MPI environment.  
MPI's message-passing model simplifies communication and removes the need for socket management.  
The result is a clean, structured file-transfer workflow that works reliably across distributed processes.

\end{document}
